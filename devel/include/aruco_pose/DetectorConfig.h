//#line 2 "/opt/ros/noetic/share/dynamic_reconfigure/cmake/../templates/ConfigType.h.template"
// *********************************************************
//
// File autogenerated for the aruco_pose package
// by the dynamic_reconfigure package.
// Please do not edit.
//
// ********************************************************/

#ifndef __aruco_pose__DETECTORCONFIG_H__
#define __aruco_pose__DETECTORCONFIG_H__

#if __cplusplus >= 201103L
#define DYNAMIC_RECONFIGURE_FINAL final
#else
#define DYNAMIC_RECONFIGURE_FINAL
#endif

#include <dynamic_reconfigure/config_tools.h>
#include <limits>
#include <ros/node_handle.h>
#include <dynamic_reconfigure/ConfigDescription.h>
#include <dynamic_reconfigure/ParamDescription.h>
#include <dynamic_reconfigure/Group.h>
#include <dynamic_reconfigure/config_init_mutex.h>
#include <boost/any.hpp>

namespace aruco_pose
{
  class DetectorConfigStatics;

  class DetectorConfig
  {
  public:
    class AbstractParamDescription : public dynamic_reconfigure::ParamDescription
    {
    public:
      AbstractParamDescription(std::string n, std::string t, uint32_t l,
          std::string d, std::string e)
      {
        name = n;
        type = t;
        level = l;
        description = d;
        edit_method = e;
      }
      virtual ~AbstractParamDescription() = default;

      virtual void clamp(DetectorConfig &config, const DetectorConfig &max, const DetectorConfig &min) const = 0;
      virtual void calcLevel(uint32_t &level, const DetectorConfig &config1, const DetectorConfig &config2) const = 0;
      virtual void fromServer(const ros::NodeHandle &nh, DetectorConfig &config) const = 0;
      virtual void toServer(const ros::NodeHandle &nh, const DetectorConfig &config) const = 0;
      virtual bool fromMessage(const dynamic_reconfigure::Config &msg, DetectorConfig &config) const = 0;
      virtual void toMessage(dynamic_reconfigure::Config &msg, const DetectorConfig &config) const = 0;
      virtual void getValue(const DetectorConfig &config, boost::any &val) const = 0;
    };

    typedef boost::shared_ptr<AbstractParamDescription> AbstractParamDescriptionPtr;
    typedef boost::shared_ptr<const AbstractParamDescription> AbstractParamDescriptionConstPtr;

    // Final keyword added to class because it has virtual methods and inherits
    // from a class with a non-virtual destructor.
    template <class T>
    class ParamDescription DYNAMIC_RECONFIGURE_FINAL : public AbstractParamDescription
    {
    public:
      ParamDescription(std::string a_name, std::string a_type, uint32_t a_level,
          std::string a_description, std::string a_edit_method, T DetectorConfig::* a_f) :
        AbstractParamDescription(a_name, a_type, a_level, a_description, a_edit_method),
        field(a_f)
      {}

      T DetectorConfig::* field;

      virtual void clamp(DetectorConfig &config, const DetectorConfig &max, const DetectorConfig &min) const override
      {
        if (config.*field > max.*field)
          config.*field = max.*field;

        if (config.*field < min.*field)
          config.*field = min.*field;
      }

      virtual void calcLevel(uint32_t &comb_level, const DetectorConfig &config1, const DetectorConfig &config2) const override
      {
        if (config1.*field != config2.*field)
          comb_level |= level;
      }

      virtual void fromServer(const ros::NodeHandle &nh, DetectorConfig &config) const override
      {
        nh.getParam(name, config.*field);
      }

      virtual void toServer(const ros::NodeHandle &nh, const DetectorConfig &config) const override
      {
        nh.setParam(name, config.*field);
      }

      virtual bool fromMessage(const dynamic_reconfigure::Config &msg, DetectorConfig &config) const override
      {
        return dynamic_reconfigure::ConfigTools::getParameter(msg, name, config.*field);
      }

      virtual void toMessage(dynamic_reconfigure::Config &msg, const DetectorConfig &config) const override
      {
        dynamic_reconfigure::ConfigTools::appendParameter(msg, name, config.*field);
      }

      virtual void getValue(const DetectorConfig &config, boost::any &val) const override
      {
        val = config.*field;
      }
    };

    class AbstractGroupDescription : public dynamic_reconfigure::Group
    {
      public:
      AbstractGroupDescription(std::string n, std::string t, int p, int i, bool s)
      {
        name = n;
        type = t;
        parent = p;
        state = s;
        id = i;
      }

      virtual ~AbstractGroupDescription() = default;

      std::vector<AbstractParamDescriptionConstPtr> abstract_parameters;
      bool state;

      virtual void toMessage(dynamic_reconfigure::Config &msg, const boost::any &config) const = 0;
      virtual bool fromMessage(const dynamic_reconfigure::Config &msg, boost::any &config) const =0;
      virtual void updateParams(boost::any &cfg, DetectorConfig &top) const= 0;
      virtual void setInitialState(boost::any &cfg) const = 0;


      void convertParams()
      {
        for(std::vector<AbstractParamDescriptionConstPtr>::const_iterator i = abstract_parameters.begin(); i != abstract_parameters.end(); ++i)
        {
          parameters.push_back(dynamic_reconfigure::ParamDescription(**i));
        }
      }
    };

    typedef boost::shared_ptr<AbstractGroupDescription> AbstractGroupDescriptionPtr;
    typedef boost::shared_ptr<const AbstractGroupDescription> AbstractGroupDescriptionConstPtr;

    // Final keyword added to class because it has virtual methods and inherits
    // from a class with a non-virtual destructor.
    template<class T, class PT>
    class GroupDescription DYNAMIC_RECONFIGURE_FINAL : public AbstractGroupDescription
    {
    public:
      GroupDescription(std::string a_name, std::string a_type, int a_parent, int a_id, bool a_s, T PT::* a_f) : AbstractGroupDescription(a_name, a_type, a_parent, a_id, a_s), field(a_f)
      {
      }

      GroupDescription(const GroupDescription<T, PT>& g): AbstractGroupDescription(g.name, g.type, g.parent, g.id, g.state), field(g.field), groups(g.groups)
      {
        parameters = g.parameters;
        abstract_parameters = g.abstract_parameters;
      }

      virtual bool fromMessage(const dynamic_reconfigure::Config &msg, boost::any &cfg) const override
      {
        PT* config = boost::any_cast<PT*>(cfg);
        if(!dynamic_reconfigure::ConfigTools::getGroupState(msg, name, (*config).*field))
          return false;

        for(std::vector<AbstractGroupDescriptionConstPtr>::const_iterator i = groups.begin(); i != groups.end(); ++i)
        {
          boost::any n = &((*config).*field);
          if(!(*i)->fromMessage(msg, n))
            return false;
        }

        return true;
      }

      virtual void setInitialState(boost::any &cfg) const override
      {
        PT* config = boost::any_cast<PT*>(cfg);
        T* group = &((*config).*field);
        group->state = state;

        for(std::vector<AbstractGroupDescriptionConstPtr>::const_iterator i = groups.begin(); i != groups.end(); ++i)
        {
          boost::any n = boost::any(&((*config).*field));
          (*i)->setInitialState(n);
        }

      }

      virtual void updateParams(boost::any &cfg, DetectorConfig &top) const override
      {
        PT* config = boost::any_cast<PT*>(cfg);

        T* f = &((*config).*field);
        f->setParams(top, abstract_parameters);

        for(std::vector<AbstractGroupDescriptionConstPtr>::const_iterator i = groups.begin(); i != groups.end(); ++i)
        {
          boost::any n = &((*config).*field);
          (*i)->updateParams(n, top);
        }
      }

      virtual void toMessage(dynamic_reconfigure::Config &msg, const boost::any &cfg) const override
      {
        const PT config = boost::any_cast<PT>(cfg);
        dynamic_reconfigure::ConfigTools::appendGroup<T>(msg, name, id, parent, config.*field);

        for(std::vector<AbstractGroupDescriptionConstPtr>::const_iterator i = groups.begin(); i != groups.end(); ++i)
        {
          (*i)->toMessage(msg, config.*field);
        }
      }

      T PT::* field;
      std::vector<DetectorConfig::AbstractGroupDescriptionConstPtr> groups;
    };

class DEFAULT
{
  public:
    DEFAULT()
    {
      state = true;
      name = "Default";
    }

    void setParams(DetectorConfig &config, const std::vector<AbstractParamDescriptionConstPtr> params)
    {
      for (std::vector<AbstractParamDescriptionConstPtr>::const_iterator _i = params.begin(); _i != params.end(); ++_i)
      {
        boost::any val;
        (*_i)->getValue(config, val);

        if("enabled"==(*_i)->name){enabled = boost::any_cast<bool>(val);}
        if("adaptiveThreshConstant"==(*_i)->name){adaptiveThreshConstant = boost::any_cast<double>(val);}
        if("adaptiveThreshWinSizeMin"==(*_i)->name){adaptiveThreshWinSizeMin = boost::any_cast<int>(val);}
        if("adaptiveThreshWinSizeMax"==(*_i)->name){adaptiveThreshWinSizeMax = boost::any_cast<int>(val);}
        if("adaptiveThreshWinSizeStep"==(*_i)->name){adaptiveThreshWinSizeStep = boost::any_cast<int>(val);}
        if("cornerRefinementMaxIterations"==(*_i)->name){cornerRefinementMaxIterations = boost::any_cast<int>(val);}
        if("cornerRefinementMethod"==(*_i)->name){cornerRefinementMethod = boost::any_cast<int>(val);}
        if("cornerRefinementMinAccuracy"==(*_i)->name){cornerRefinementMinAccuracy = boost::any_cast<double>(val);}
        if("cornerRefinementWinSize"==(*_i)->name){cornerRefinementWinSize = boost::any_cast<int>(val);}
        if("detectInvertedMarker"==(*_i)->name){detectInvertedMarker = boost::any_cast<bool>(val);}
        if("errorCorrectionRate"==(*_i)->name){errorCorrectionRate = boost::any_cast<double>(val);}
        if("minCornerDistanceRate"==(*_i)->name){minCornerDistanceRate = boost::any_cast<double>(val);}
        if("markerBorderBits"==(*_i)->name){markerBorderBits = boost::any_cast<int>(val);}
        if("maxErroneousBitsInBorderRate"==(*_i)->name){maxErroneousBitsInBorderRate = boost::any_cast<double>(val);}
        if("minDistanceToBorder"==(*_i)->name){minDistanceToBorder = boost::any_cast<int>(val);}
        if("minMarkerDistanceRate"==(*_i)->name){minMarkerDistanceRate = boost::any_cast<double>(val);}
        if("minMarkerPerimeterRate"==(*_i)->name){minMarkerPerimeterRate = boost::any_cast<double>(val);}
        if("maxMarkerPerimeterRate"==(*_i)->name){maxMarkerPerimeterRate = boost::any_cast<double>(val);}
        if("minOtsuStdDev"==(*_i)->name){minOtsuStdDev = boost::any_cast<double>(val);}
        if("perspectiveRemoveIgnoredMarginPerCell"==(*_i)->name){perspectiveRemoveIgnoredMarginPerCell = boost::any_cast<double>(val);}
        if("perspectiveRemovePixelPerCell"==(*_i)->name){perspectiveRemovePixelPerCell = boost::any_cast<int>(val);}
        if("polygonalApproxAccuracyRate"==(*_i)->name){polygonalApproxAccuracyRate = boost::any_cast<double>(val);}
        if("aprilTagQuadDecimate"==(*_i)->name){aprilTagQuadDecimate = boost::any_cast<double>(val);}
        if("aprilTagQuadSigma"==(*_i)->name){aprilTagQuadSigma = boost::any_cast<double>(val);}
      }
    }

    bool enabled;
double adaptiveThreshConstant;
int adaptiveThreshWinSizeMin;
int adaptiveThreshWinSizeMax;
int adaptiveThreshWinSizeStep;
int cornerRefinementMaxIterations;
int cornerRefinementMethod;
double cornerRefinementMinAccuracy;
int cornerRefinementWinSize;
bool detectInvertedMarker;
double errorCorrectionRate;
double minCornerDistanceRate;
int markerBorderBits;
double maxErroneousBitsInBorderRate;
int minDistanceToBorder;
double minMarkerDistanceRate;
double minMarkerPerimeterRate;
double maxMarkerPerimeterRate;
double minOtsuStdDev;
double perspectiveRemoveIgnoredMarginPerCell;
int perspectiveRemovePixelPerCell;
double polygonalApproxAccuracyRate;
double aprilTagQuadDecimate;
double aprilTagQuadSigma;

    bool state;
    std::string name;

    
}groups;



//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      bool enabled;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      double adaptiveThreshConstant;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      int adaptiveThreshWinSizeMin;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      int adaptiveThreshWinSizeMax;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      int adaptiveThreshWinSizeStep;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      int cornerRefinementMaxIterations;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      int cornerRefinementMethod;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      double cornerRefinementMinAccuracy;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      int cornerRefinementWinSize;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      bool detectInvertedMarker;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      double errorCorrectionRate;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      double minCornerDistanceRate;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      int markerBorderBits;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      double maxErroneousBitsInBorderRate;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      int minDistanceToBorder;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      double minMarkerDistanceRate;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      double minMarkerPerimeterRate;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      double maxMarkerPerimeterRate;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      double minOtsuStdDev;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      double perspectiveRemoveIgnoredMarginPerCell;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      int perspectiveRemovePixelPerCell;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      double polygonalApproxAccuracyRate;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      double aprilTagQuadDecimate;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      double aprilTagQuadSigma;
//#line 231 "/opt/ros/noetic/share/dynamic_reconfigure/cmake/../templates/ConfigType.h.template"

    bool __fromMessage__(dynamic_reconfigure::Config &msg)
    {
      const std::vector<AbstractParamDescriptionConstPtr> &__param_descriptions__ = __getParamDescriptions__();
      const std::vector<AbstractGroupDescriptionConstPtr> &__group_descriptions__ = __getGroupDescriptions__();

      int count = 0;
      for (std::vector<AbstractParamDescriptionConstPtr>::const_iterator i = __param_descriptions__.begin(); i != __param_descriptions__.end(); ++i)
        if ((*i)->fromMessage(msg, *this))
          count++;

      for (std::vector<AbstractGroupDescriptionConstPtr>::const_iterator i = __group_descriptions__.begin(); i != __group_descriptions__.end(); i ++)
      {
        if ((*i)->id == 0)
        {
          boost::any n = boost::any(this);
          (*i)->updateParams(n, *this);
          (*i)->fromMessage(msg, n);
        }
      }

      if (count != dynamic_reconfigure::ConfigTools::size(msg))
      {
        ROS_ERROR("DetectorConfig::__fromMessage__ called with an unexpected parameter.");
        ROS_ERROR("Booleans:");
        for (unsigned int i = 0; i < msg.bools.size(); i++)
          ROS_ERROR("  %s", msg.bools[i].name.c_str());
        ROS_ERROR("Integers:");
        for (unsigned int i = 0; i < msg.ints.size(); i++)
          ROS_ERROR("  %s", msg.ints[i].name.c_str());
        ROS_ERROR("Doubles:");
        for (unsigned int i = 0; i < msg.doubles.size(); i++)
          ROS_ERROR("  %s", msg.doubles[i].name.c_str());
        ROS_ERROR("Strings:");
        for (unsigned int i = 0; i < msg.strs.size(); i++)
          ROS_ERROR("  %s", msg.strs[i].name.c_str());
        // @todo Check that there are no duplicates. Make this error more
        // explicit.
        return false;
      }
      return true;
    }

    // This version of __toMessage__ is used during initialization of
    // statics when __getParamDescriptions__ can't be called yet.
    void __toMessage__(dynamic_reconfigure::Config &msg, const std::vector<AbstractParamDescriptionConstPtr> &__param_descriptions__, const std::vector<AbstractGroupDescriptionConstPtr> &__group_descriptions__) const
    {
      dynamic_reconfigure::ConfigTools::clear(msg);
      for (std::vector<AbstractParamDescriptionConstPtr>::const_iterator i = __param_descriptions__.begin(); i != __param_descriptions__.end(); ++i)
        (*i)->toMessage(msg, *this);

      for (std::vector<AbstractGroupDescriptionConstPtr>::const_iterator i = __group_descriptions__.begin(); i != __group_descriptions__.end(); ++i)
      {
        if((*i)->id == 0)
        {
          (*i)->toMessage(msg, *this);
        }
      }
    }

    void __toMessage__(dynamic_reconfigure::Config &msg) const
    {
      const std::vector<AbstractParamDescriptionConstPtr> &__param_descriptions__ = __getParamDescriptions__();
      const std::vector<AbstractGroupDescriptionConstPtr> &__group_descriptions__ = __getGroupDescriptions__();
      __toMessage__(msg, __param_descriptions__, __group_descriptions__);
    }

    void __toServer__(const ros::NodeHandle &nh) const
    {
      const std::vector<AbstractParamDescriptionConstPtr> &__param_descriptions__ = __getParamDescriptions__();
      for (std::vector<AbstractParamDescriptionConstPtr>::const_iterator i = __param_descriptions__.begin(); i != __param_descriptions__.end(); ++i)
        (*i)->toServer(nh, *this);
    }

    void __fromServer__(const ros::NodeHandle &nh)
    {
      static bool setup=false;

      const std::vector<AbstractParamDescriptionConstPtr> &__param_descriptions__ = __getParamDescriptions__();
      for (std::vector<AbstractParamDescriptionConstPtr>::const_iterator i = __param_descriptions__.begin(); i != __param_descriptions__.end(); ++i)
        (*i)->fromServer(nh, *this);

      const std::vector<AbstractGroupDescriptionConstPtr> &__group_descriptions__ = __getGroupDescriptions__();
      for (std::vector<AbstractGroupDescriptionConstPtr>::const_iterator i = __group_descriptions__.begin(); i != __group_descriptions__.end(); i++){
        if (!setup && (*i)->id == 0) {
          setup = true;
          boost::any n = boost::any(this);
          (*i)->setInitialState(n);
        }
      }
    }

    void __clamp__()
    {
      const std::vector<AbstractParamDescriptionConstPtr> &__param_descriptions__ = __getParamDescriptions__();
      const DetectorConfig &__max__ = __getMax__();
      const DetectorConfig &__min__ = __getMin__();
      for (std::vector<AbstractParamDescriptionConstPtr>::const_iterator i = __param_descriptions__.begin(); i != __param_descriptions__.end(); ++i)
        (*i)->clamp(*this, __max__, __min__);
    }

    uint32_t __level__(const DetectorConfig &config) const
    {
      const std::vector<AbstractParamDescriptionConstPtr> &__param_descriptions__ = __getParamDescriptions__();
      uint32_t level = 0;
      for (std::vector<AbstractParamDescriptionConstPtr>::const_iterator i = __param_descriptions__.begin(); i != __param_descriptions__.end(); ++i)
        (*i)->calcLevel(level, config, *this);
      return level;
    }

    static const dynamic_reconfigure::ConfigDescription &__getDescriptionMessage__();
    static const DetectorConfig &__getDefault__();
    static const DetectorConfig &__getMax__();
    static const DetectorConfig &__getMin__();
    static const std::vector<AbstractParamDescriptionConstPtr> &__getParamDescriptions__();
    static const std::vector<AbstractGroupDescriptionConstPtr> &__getGroupDescriptions__();

  private:
    static const DetectorConfigStatics *__get_statics__();
  };

  template <> // Max and min are ignored for strings.
  inline void DetectorConfig::ParamDescription<std::string>::clamp(DetectorConfig &config, const DetectorConfig &max, const DetectorConfig &min) const
  {
    (void) config;
    (void) min;
    (void) max;
    return;
  }

  class DetectorConfigStatics
  {
    friend class DetectorConfig;

    DetectorConfigStatics()
    {
DetectorConfig::GroupDescription<DetectorConfig::DEFAULT, DetectorConfig> Default("Default", "", 0, 0, true, &DetectorConfig::groups);
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __min__.enabled = 0;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __max__.enabled = 1;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __default__.enabled = 1;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Default.abstract_parameters.push_back(DetectorConfig::AbstractParamDescriptionConstPtr(new DetectorConfig::ParamDescription<bool>("enabled", "bool", 0, "if detection enabled", "", &DetectorConfig::enabled)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __param_descriptions__.push_back(DetectorConfig::AbstractParamDescriptionConstPtr(new DetectorConfig::ParamDescription<bool>("enabled", "bool", 0, "if detection enabled", "", &DetectorConfig::enabled)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __min__.adaptiveThreshConstant = 0.0;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __max__.adaptiveThreshConstant = 100.0;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __default__.adaptiveThreshConstant = 7.0;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Default.abstract_parameters.push_back(DetectorConfig::AbstractParamDescriptionConstPtr(new DetectorConfig::ParamDescription<double>("adaptiveThreshConstant", "double", 0, "Constant for adaptive thresholding before finding contours", "", &DetectorConfig::adaptiveThreshConstant)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __param_descriptions__.push_back(DetectorConfig::AbstractParamDescriptionConstPtr(new DetectorConfig::ParamDescription<double>("adaptiveThreshConstant", "double", 0, "Constant for adaptive thresholding before finding contours", "", &DetectorConfig::adaptiveThreshConstant)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __min__.adaptiveThreshWinSizeMin = 1;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __max__.adaptiveThreshWinSizeMin = 100;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __default__.adaptiveThreshWinSizeMin = 3;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Default.abstract_parameters.push_back(DetectorConfig::AbstractParamDescriptionConstPtr(new DetectorConfig::ParamDescription<int>("adaptiveThreshWinSizeMin", "int", 0, "Minimum window size for adaptive thresholding before finding contours", "", &DetectorConfig::adaptiveThreshWinSizeMin)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __param_descriptions__.push_back(DetectorConfig::AbstractParamDescriptionConstPtr(new DetectorConfig::ParamDescription<int>("adaptiveThreshWinSizeMin", "int", 0, "Minimum window size for adaptive thresholding before finding contours", "", &DetectorConfig::adaptiveThreshWinSizeMin)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __min__.adaptiveThreshWinSizeMax = 1;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __max__.adaptiveThreshWinSizeMax = 100;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __default__.adaptiveThreshWinSizeMax = 23;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Default.abstract_parameters.push_back(DetectorConfig::AbstractParamDescriptionConstPtr(new DetectorConfig::ParamDescription<int>("adaptiveThreshWinSizeMax", "int", 0, "Maximum window size for adaptive thresholding before finding contours", "", &DetectorConfig::adaptiveThreshWinSizeMax)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __param_descriptions__.push_back(DetectorConfig::AbstractParamDescriptionConstPtr(new DetectorConfig::ParamDescription<int>("adaptiveThreshWinSizeMax", "int", 0, "Maximum window size for adaptive thresholding before finding contours", "", &DetectorConfig::adaptiveThreshWinSizeMax)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __min__.adaptiveThreshWinSizeStep = 1;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __max__.adaptiveThreshWinSizeStep = 100;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __default__.adaptiveThreshWinSizeStep = 10;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Default.abstract_parameters.push_back(DetectorConfig::AbstractParamDescriptionConstPtr(new DetectorConfig::ParamDescription<int>("adaptiveThreshWinSizeStep", "int", 0, "Increments from adaptiveThreshWinSizeMin to adaptiveThreshWinSizeMax during the thresholding", "", &DetectorConfig::adaptiveThreshWinSizeStep)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __param_descriptions__.push_back(DetectorConfig::AbstractParamDescriptionConstPtr(new DetectorConfig::ParamDescription<int>("adaptiveThreshWinSizeStep", "int", 0, "Increments from adaptiveThreshWinSizeMin to adaptiveThreshWinSizeMax during the thresholding", "", &DetectorConfig::adaptiveThreshWinSizeStep)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __min__.cornerRefinementMaxIterations = 1;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __max__.cornerRefinementMaxIterations = 1000;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __default__.cornerRefinementMaxIterations = 30;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Default.abstract_parameters.push_back(DetectorConfig::AbstractParamDescriptionConstPtr(new DetectorConfig::ParamDescription<int>("cornerRefinementMaxIterations", "int", 0, "Maximum number of iterations for stop criteria of the corner refinement process", "", &DetectorConfig::cornerRefinementMaxIterations)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __param_descriptions__.push_back(DetectorConfig::AbstractParamDescriptionConstPtr(new DetectorConfig::ParamDescription<int>("cornerRefinementMaxIterations", "int", 0, "Maximum number of iterations for stop criteria of the corner refinement process", "", &DetectorConfig::cornerRefinementMaxIterations)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __min__.cornerRefinementMethod = 0;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __max__.cornerRefinementMethod = 3;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __default__.cornerRefinementMethod = 0;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Default.abstract_parameters.push_back(DetectorConfig::AbstractParamDescriptionConstPtr(new DetectorConfig::ParamDescription<int>("cornerRefinementMethod", "int", 0, "Corner refinement method", "{'enum': [{'name': 'CORNER_REFINE_NONE', 'type': 'int', 'value': 0, 'srcline': 33, 'srcfile': '/home/enaitz/catkin_ws/src/clover/aruco_pose/cfg/Detector.cfg', 'description': 'No refinement', 'ctype': 'int', 'cconsttype': 'const int'}, {'name': 'CORNER_REFINE_SUBPIX', 'type': 'int', 'value': 1, 'srcline': 34, 'srcfile': '/home/enaitz/catkin_ws/src/clover/aruco_pose/cfg/Detector.cfg', 'description': 'Do subpixel refinement', 'ctype': 'int', 'cconsttype': 'const int'}, {'name': 'CORNER_REFINE_CONTOUR', 'type': 'int', 'value': 2, 'srcline': 35, 'srcfile': '/home/enaitz/catkin_ws/src/clover/aruco_pose/cfg/Detector.cfg', 'description': 'Use contour-Points', 'ctype': 'int', 'cconsttype': 'const int'}, {'name': 'CORNER_REFINE_APRILTAG', 'type': 'int', 'value': 3, 'srcline': 36, 'srcfile': '/home/enaitz/catkin_ws/src/clover/aruco_pose/cfg/Detector.cfg', 'description': 'Use the AprilTag2 approach', 'ctype': 'int', 'cconsttype': 'const int'}], 'enum_description': 'An enum to set corner refinement method'}", &DetectorConfig::cornerRefinementMethod)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __param_descriptions__.push_back(DetectorConfig::AbstractParamDescriptionConstPtr(new DetectorConfig::ParamDescription<int>("cornerRefinementMethod", "int", 0, "Corner refinement method", "{'enum': [{'name': 'CORNER_REFINE_NONE', 'type': 'int', 'value': 0, 'srcline': 33, 'srcfile': '/home/enaitz/catkin_ws/src/clover/aruco_pose/cfg/Detector.cfg', 'description': 'No refinement', 'ctype': 'int', 'cconsttype': 'const int'}, {'name': 'CORNER_REFINE_SUBPIX', 'type': 'int', 'value': 1, 'srcline': 34, 'srcfile': '/home/enaitz/catkin_ws/src/clover/aruco_pose/cfg/Detector.cfg', 'description': 'Do subpixel refinement', 'ctype': 'int', 'cconsttype': 'const int'}, {'name': 'CORNER_REFINE_CONTOUR', 'type': 'int', 'value': 2, 'srcline': 35, 'srcfile': '/home/enaitz/catkin_ws/src/clover/aruco_pose/cfg/Detector.cfg', 'description': 'Use contour-Points', 'ctype': 'int', 'cconsttype': 'const int'}, {'name': 'CORNER_REFINE_APRILTAG', 'type': 'int', 'value': 3, 'srcline': 36, 'srcfile': '/home/enaitz/catkin_ws/src/clover/aruco_pose/cfg/Detector.cfg', 'description': 'Use the AprilTag2 approach', 'ctype': 'int', 'cconsttype': 'const int'}], 'enum_description': 'An enum to set corner refinement method'}", &DetectorConfig::cornerRefinementMethod)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __min__.cornerRefinementMinAccuracy = 0.0;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __max__.cornerRefinementMinAccuracy = 1.0;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __default__.cornerRefinementMinAccuracy = 0.1;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Default.abstract_parameters.push_back(DetectorConfig::AbstractParamDescriptionConstPtr(new DetectorConfig::ParamDescription<double>("cornerRefinementMinAccuracy", "double", 0, "Minimum error for the stop criteria of the corner refinement process", "", &DetectorConfig::cornerRefinementMinAccuracy)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __param_descriptions__.push_back(DetectorConfig::AbstractParamDescriptionConstPtr(new DetectorConfig::ParamDescription<double>("cornerRefinementMinAccuracy", "double", 0, "Minimum error for the stop criteria of the corner refinement process", "", &DetectorConfig::cornerRefinementMinAccuracy)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __min__.cornerRefinementWinSize = 1;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __max__.cornerRefinementWinSize = 100;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __default__.cornerRefinementWinSize = 5;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Default.abstract_parameters.push_back(DetectorConfig::AbstractParamDescriptionConstPtr(new DetectorConfig::ParamDescription<int>("cornerRefinementWinSize", "int", 0, "Window size for the corner refinement process (in pixels)", "", &DetectorConfig::cornerRefinementWinSize)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __param_descriptions__.push_back(DetectorConfig::AbstractParamDescriptionConstPtr(new DetectorConfig::ParamDescription<int>("cornerRefinementWinSize", "int", 0, "Window size for the corner refinement process (in pixels)", "", &DetectorConfig::cornerRefinementWinSize)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __min__.detectInvertedMarker = 0;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __max__.detectInvertedMarker = 1;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __default__.detectInvertedMarker = 0;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Default.abstract_parameters.push_back(DetectorConfig::AbstractParamDescriptionConstPtr(new DetectorConfig::ParamDescription<bool>("detectInvertedMarker", "bool", 0, "check if there is a white marker. In order to generate a 'white' marker just invert a normal marker by using a tilde", "", &DetectorConfig::detectInvertedMarker)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __param_descriptions__.push_back(DetectorConfig::AbstractParamDescriptionConstPtr(new DetectorConfig::ParamDescription<bool>("detectInvertedMarker", "bool", 0, "check if there is a white marker. In order to generate a 'white' marker just invert a normal marker by using a tilde", "", &DetectorConfig::detectInvertedMarker)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __min__.errorCorrectionRate = 0.0;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __max__.errorCorrectionRate = 1.0;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __default__.errorCorrectionRate = 0.6;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Default.abstract_parameters.push_back(DetectorConfig::AbstractParamDescriptionConstPtr(new DetectorConfig::ParamDescription<double>("errorCorrectionRate", "double", 0, "Error correction rate respect to the maximum error correction capability for each dictionary", "", &DetectorConfig::errorCorrectionRate)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __param_descriptions__.push_back(DetectorConfig::AbstractParamDescriptionConstPtr(new DetectorConfig::ParamDescription<double>("errorCorrectionRate", "double", 0, "Error correction rate respect to the maximum error correction capability for each dictionary", "", &DetectorConfig::errorCorrectionRate)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __min__.minCornerDistanceRate = 0.0;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __max__.minCornerDistanceRate = 0.25;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __default__.minCornerDistanceRate = 0.05;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Default.abstract_parameters.push_back(DetectorConfig::AbstractParamDescriptionConstPtr(new DetectorConfig::ParamDescription<double>("minCornerDistanceRate", "double", 0, "Minimum distance between corners for detected markers relative to its perimeter", "", &DetectorConfig::minCornerDistanceRate)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __param_descriptions__.push_back(DetectorConfig::AbstractParamDescriptionConstPtr(new DetectorConfig::ParamDescription<double>("minCornerDistanceRate", "double", 0, "Minimum distance between corners for detected markers relative to its perimeter", "", &DetectorConfig::minCornerDistanceRate)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __min__.markerBorderBits = 1;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __max__.markerBorderBits = 10;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __default__.markerBorderBits = 1;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Default.abstract_parameters.push_back(DetectorConfig::AbstractParamDescriptionConstPtr(new DetectorConfig::ParamDescription<int>("markerBorderBits", "int", 0, "Number of bits of the marker border, i.e. marker border width", "", &DetectorConfig::markerBorderBits)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __param_descriptions__.push_back(DetectorConfig::AbstractParamDescriptionConstPtr(new DetectorConfig::ParamDescription<int>("markerBorderBits", "int", 0, "Number of bits of the marker border, i.e. marker border width", "", &DetectorConfig::markerBorderBits)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __min__.maxErroneousBitsInBorderRate = 0.0;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __max__.maxErroneousBitsInBorderRate = 1.0;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __default__.maxErroneousBitsInBorderRate = 0.35;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Default.abstract_parameters.push_back(DetectorConfig::AbstractParamDescriptionConstPtr(new DetectorConfig::ParamDescription<double>("maxErroneousBitsInBorderRate", "double", 0, "Maximum number of accepted erroneous bits in the border (i.e. number of allowed white bits in the border)", "", &DetectorConfig::maxErroneousBitsInBorderRate)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __param_descriptions__.push_back(DetectorConfig::AbstractParamDescriptionConstPtr(new DetectorConfig::ParamDescription<double>("maxErroneousBitsInBorderRate", "double", 0, "Maximum number of accepted erroneous bits in the border (i.e. number of allowed white bits in the border)", "", &DetectorConfig::maxErroneousBitsInBorderRate)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __min__.minDistanceToBorder = 0;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __max__.minDistanceToBorder = 1000;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __default__.minDistanceToBorder = 3;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Default.abstract_parameters.push_back(DetectorConfig::AbstractParamDescriptionConstPtr(new DetectorConfig::ParamDescription<int>("minDistanceToBorder", "int", 0, "Minimum distance of any corner to the image border for detected markers (in pixels)", "", &DetectorConfig::minDistanceToBorder)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __param_descriptions__.push_back(DetectorConfig::AbstractParamDescriptionConstPtr(new DetectorConfig::ParamDescription<int>("minDistanceToBorder", "int", 0, "Minimum distance of any corner to the image border for detected markers (in pixels)", "", &DetectorConfig::minDistanceToBorder)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __min__.minMarkerDistanceRate = 0.0;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __max__.minMarkerDistanceRate = 1.0;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __default__.minMarkerDistanceRate = 0.05;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Default.abstract_parameters.push_back(DetectorConfig::AbstractParamDescriptionConstPtr(new DetectorConfig::ParamDescription<double>("minMarkerDistanceRate", "double", 0, "minimum mean distance beetween two marker corners to be considered similar, so that the smaller one is removed. The rate is relative to the smaller perimeter of the two markers", "", &DetectorConfig::minMarkerDistanceRate)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __param_descriptions__.push_back(DetectorConfig::AbstractParamDescriptionConstPtr(new DetectorConfig::ParamDescription<double>("minMarkerDistanceRate", "double", 0, "minimum mean distance beetween two marker corners to be considered similar, so that the smaller one is removed. The rate is relative to the smaller perimeter of the two markers", "", &DetectorConfig::minMarkerDistanceRate)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __min__.minMarkerPerimeterRate = 0.0;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __max__.minMarkerPerimeterRate = 4.0;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __default__.minMarkerPerimeterRate = 0.03;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Default.abstract_parameters.push_back(DetectorConfig::AbstractParamDescriptionConstPtr(new DetectorConfig::ParamDescription<double>("minMarkerPerimeterRate", "double", 0, "Determine minimum perimeter for marker contour to be detected. This is defined as a rate respect to the maximum dimension of the input image", "", &DetectorConfig::minMarkerPerimeterRate)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __param_descriptions__.push_back(DetectorConfig::AbstractParamDescriptionConstPtr(new DetectorConfig::ParamDescription<double>("minMarkerPerimeterRate", "double", 0, "Determine minimum perimeter for marker contour to be detected. This is defined as a rate respect to the maximum dimension of the input image", "", &DetectorConfig::minMarkerPerimeterRate)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __min__.maxMarkerPerimeterRate = 0.0;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __max__.maxMarkerPerimeterRate = 4.0;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __default__.maxMarkerPerimeterRate = 4.0;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Default.abstract_parameters.push_back(DetectorConfig::AbstractParamDescriptionConstPtr(new DetectorConfig::ParamDescription<double>("maxMarkerPerimeterRate", "double", 0, "Determine maximum perimeter for marker contour to be detected. This is defined as a rate respect to the maximum dimension of the input image", "", &DetectorConfig::maxMarkerPerimeterRate)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __param_descriptions__.push_back(DetectorConfig::AbstractParamDescriptionConstPtr(new DetectorConfig::ParamDescription<double>("maxMarkerPerimeterRate", "double", 0, "Determine maximum perimeter for marker contour to be detected. This is defined as a rate respect to the maximum dimension of the input image", "", &DetectorConfig::maxMarkerPerimeterRate)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __min__.minOtsuStdDev = 0.0;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __max__.minOtsuStdDev = 100.0;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __default__.minOtsuStdDev = 5.0;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Default.abstract_parameters.push_back(DetectorConfig::AbstractParamDescriptionConstPtr(new DetectorConfig::ParamDescription<double>("minOtsuStdDev", "double", 0, "Minimun standard deviation in pixels values during the decodification step to apply Otsu thresholding (otherwise, all the bits are set to 0 or 1 depending on mean higher than 128 or not)", "", &DetectorConfig::minOtsuStdDev)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __param_descriptions__.push_back(DetectorConfig::AbstractParamDescriptionConstPtr(new DetectorConfig::ParamDescription<double>("minOtsuStdDev", "double", 0, "Minimun standard deviation in pixels values during the decodification step to apply Otsu thresholding (otherwise, all the bits are set to 0 or 1 depending on mean higher than 128 or not)", "", &DetectorConfig::minOtsuStdDev)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __min__.perspectiveRemoveIgnoredMarginPerCell = 0.0;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __max__.perspectiveRemoveIgnoredMarginPerCell = 1.0;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __default__.perspectiveRemoveIgnoredMarginPerCell = 0.13;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Default.abstract_parameters.push_back(DetectorConfig::AbstractParamDescriptionConstPtr(new DetectorConfig::ParamDescription<double>("perspectiveRemoveIgnoredMarginPerCell", "double", 0, "Width of the margin of pixels on each cell not considered for the determination of the cell bit. Represents the rate respect to the total size of the cell, i.e. perpectiveRemovePixelPerCell", "", &DetectorConfig::perspectiveRemoveIgnoredMarginPerCell)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __param_descriptions__.push_back(DetectorConfig::AbstractParamDescriptionConstPtr(new DetectorConfig::ParamDescription<double>("perspectiveRemoveIgnoredMarginPerCell", "double", 0, "Width of the margin of pixels on each cell not considered for the determination of the cell bit. Represents the rate respect to the total size of the cell, i.e. perpectiveRemovePixelPerCell", "", &DetectorConfig::perspectiveRemoveIgnoredMarginPerCell)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __min__.perspectiveRemovePixelPerCell = 1;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __max__.perspectiveRemovePixelPerCell = 100;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __default__.perspectiveRemovePixelPerCell = 4;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Default.abstract_parameters.push_back(DetectorConfig::AbstractParamDescriptionConstPtr(new DetectorConfig::ParamDescription<int>("perspectiveRemovePixelPerCell", "int", 0, "Number of bits (per dimension) for each cell of the marker when removing the perspective", "", &DetectorConfig::perspectiveRemovePixelPerCell)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __param_descriptions__.push_back(DetectorConfig::AbstractParamDescriptionConstPtr(new DetectorConfig::ParamDescription<int>("perspectiveRemovePixelPerCell", "int", 0, "Number of bits (per dimension) for each cell of the marker when removing the perspective", "", &DetectorConfig::perspectiveRemovePixelPerCell)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __min__.polygonalApproxAccuracyRate = 0.0;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __max__.polygonalApproxAccuracyRate = 1.0;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __default__.polygonalApproxAccuracyRate = 0.03;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Default.abstract_parameters.push_back(DetectorConfig::AbstractParamDescriptionConstPtr(new DetectorConfig::ParamDescription<double>("polygonalApproxAccuracyRate", "double", 0, "Minimum accuracy during the polygonal approximation process to determine which contours are squares", "", &DetectorConfig::polygonalApproxAccuracyRate)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __param_descriptions__.push_back(DetectorConfig::AbstractParamDescriptionConstPtr(new DetectorConfig::ParamDescription<double>("polygonalApproxAccuracyRate", "double", 0, "Minimum accuracy during the polygonal approximation process to determine which contours are squares", "", &DetectorConfig::polygonalApproxAccuracyRate)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __min__.aprilTagQuadDecimate = 0.0;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __max__.aprilTagQuadDecimate = 1000.0;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __default__.aprilTagQuadDecimate = 0.0;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Default.abstract_parameters.push_back(DetectorConfig::AbstractParamDescriptionConstPtr(new DetectorConfig::ParamDescription<double>("aprilTagQuadDecimate", "double", 0, "Detection of quads can be done on a lower-resolution image, improving speed at a cost of pose accuracy and a slight decrease in detection rate. Decoding the binary payload is still done at full resolution", "", &DetectorConfig::aprilTagQuadDecimate)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __param_descriptions__.push_back(DetectorConfig::AbstractParamDescriptionConstPtr(new DetectorConfig::ParamDescription<double>("aprilTagQuadDecimate", "double", 0, "Detection of quads can be done on a lower-resolution image, improving speed at a cost of pose accuracy and a slight decrease in detection rate. Decoding the binary payload is still done at full resolution", "", &DetectorConfig::aprilTagQuadDecimate)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __min__.aprilTagQuadSigma = 0.0;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __max__.aprilTagQuadSigma = 1000.0;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __default__.aprilTagQuadSigma = 0.0;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Default.abstract_parameters.push_back(DetectorConfig::AbstractParamDescriptionConstPtr(new DetectorConfig::ParamDescription<double>("aprilTagQuadSigma", "double", 0, "What Gaussian blur should be applied to the segmented image (used for quad detection?) Parameter is the standard deviation in pixels. Very noisy images benefit from non-zero values", "", &DetectorConfig::aprilTagQuadSigma)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __param_descriptions__.push_back(DetectorConfig::AbstractParamDescriptionConstPtr(new DetectorConfig::ParamDescription<double>("aprilTagQuadSigma", "double", 0, "What Gaussian blur should be applied to the segmented image (used for quad detection?) Parameter is the standard deviation in pixels. Very noisy images benefit from non-zero values", "", &DetectorConfig::aprilTagQuadSigma)));
//#line 246 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Default.convertParams();
//#line 246 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __group_descriptions__.push_back(DetectorConfig::AbstractGroupDescriptionConstPtr(new DetectorConfig::GroupDescription<DetectorConfig::DEFAULT, DetectorConfig>(Default)));
//#line 369 "/opt/ros/noetic/share/dynamic_reconfigure/cmake/../templates/ConfigType.h.template"

      for (std::vector<DetectorConfig::AbstractGroupDescriptionConstPtr>::const_iterator i = __group_descriptions__.begin(); i != __group_descriptions__.end(); ++i)
      {
        __description_message__.groups.push_back(**i);
      }
      __max__.__toMessage__(__description_message__.max, __param_descriptions__, __group_descriptions__);
      __min__.__toMessage__(__description_message__.min, __param_descriptions__, __group_descriptions__);
      __default__.__toMessage__(__description_message__.dflt, __param_descriptions__, __group_descriptions__);
    }
    std::vector<DetectorConfig::AbstractParamDescriptionConstPtr> __param_descriptions__;
    std::vector<DetectorConfig::AbstractGroupDescriptionConstPtr> __group_descriptions__;
    DetectorConfig __max__;
    DetectorConfig __min__;
    DetectorConfig __default__;
    dynamic_reconfigure::ConfigDescription __description_message__;

    static const DetectorConfigStatics *get_instance()
    {
      // Split this off in a separate function because I know that
      // instance will get initialized the first time get_instance is
      // called, and I am guaranteeing that get_instance gets called at
      // most once.
      static DetectorConfigStatics instance;
      return &instance;
    }
  };

  inline const dynamic_reconfigure::ConfigDescription &DetectorConfig::__getDescriptionMessage__()
  {
    return __get_statics__()->__description_message__;
  }

  inline const DetectorConfig &DetectorConfig::__getDefault__()
  {
    return __get_statics__()->__default__;
  }

  inline const DetectorConfig &DetectorConfig::__getMax__()
  {
    return __get_statics__()->__max__;
  }

  inline const DetectorConfig &DetectorConfig::__getMin__()
  {
    return __get_statics__()->__min__;
  }

  inline const std::vector<DetectorConfig::AbstractParamDescriptionConstPtr> &DetectorConfig::__getParamDescriptions__()
  {
    return __get_statics__()->__param_descriptions__;
  }

  inline const std::vector<DetectorConfig::AbstractGroupDescriptionConstPtr> &DetectorConfig::__getGroupDescriptions__()
  {
    return __get_statics__()->__group_descriptions__;
  }

  inline const DetectorConfigStatics *DetectorConfig::__get_statics__()
  {
    const static DetectorConfigStatics *statics;

    if (statics) // Common case
      return statics;

    boost::mutex::scoped_lock lock(dynamic_reconfigure::__init_mutex__);

    if (statics) // In case we lost a race.
      return statics;

    statics = DetectorConfigStatics::get_instance();

    return statics;
  }

//#line 33 "/home/enaitz/catkin_ws/src/clover/aruco_pose/cfg/Detector.cfg"
      const int Detector_CORNER_REFINE_NONE = 0;
//#line 34 "/home/enaitz/catkin_ws/src/clover/aruco_pose/cfg/Detector.cfg"
      const int Detector_CORNER_REFINE_SUBPIX = 1;
//#line 35 "/home/enaitz/catkin_ws/src/clover/aruco_pose/cfg/Detector.cfg"
      const int Detector_CORNER_REFINE_CONTOUR = 2;
//#line 36 "/home/enaitz/catkin_ws/src/clover/aruco_pose/cfg/Detector.cfg"
      const int Detector_CORNER_REFINE_APRILTAG = 3;
}

#undef DYNAMIC_RECONFIGURE_FINAL

#endif // __DETECTORRECONFIGURATOR_H__
